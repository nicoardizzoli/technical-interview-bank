1) ntier structure
2) en los services no se usaron interfaces ya que solamente vamos a usar una implementacion, si necesitabamos configurar varias implementaciones si.
3) usamos mapstruct para los mapeos de dto a clase
4) usamos @SuperBuilder de lombok para que el mapstruct tome la herencia de las clases
5) para crear imagen de la base de datos ya con todo creado: https://www.youtube.com/watch?v=EIHY_CY5J0k&t=303s&ab_channel=DailyCodeBuffer
6) validar los DTO con javax.validation (etiquetas @NotNull, @NotBlank, etc) y poner el @Valid en el controller.
7) custom exceptions, con un ExceptionPayload hecho por mi, y con el handler para las customs exceptions con @ControllerAdvice y @ExceptionHandler.
8) en el movimiento controller, se puede parsear el string de un @RequestPram a por ej Date
9) se uso herencia entre Persona y Cliente con las anotations: @Inheritance(strategy = InheritanceType.JOINED)  en persona, y en cliente: @PrimaryKeyJoinColumn(name = "persona_id")
10) se puede formatear el string del payload con @JsonFormat de los dtos.
11) COMANDO PARA CORRER DOCKER COMPOSE SIN INTELLIJ: docker compose -f "docker-compose-postgres.yml" up -d --build
12) para entrar en docker desde CLI a un container:
    para poder correr la CLI de postgres en un docker container:


    docker exec -it "nombre container" bash
    psql -U "usuario" "nombre de la db"

    comandos cli de postgres:
    \l para listar las bases
    \d para ver descimpion
    \c nombredb para conectarme


    PARA HACER DATA FAKE PARA LA BASE DE DATOS:
    https://www.mockaroo.com/


    PARA CORRER UN .sql en una db en docker desde un archivo local:

    cat ./query.sql | docker exec -i <container-name> psql -U <user> -d <database>