Kubernetes AKA k8s is a application orchestrator
-Deploy and manage containers
-scale up and down according demand
-zero downtime deployments
-rollbacks

-Kubernetes cluster
 masterNode, and workernodes

master node esta formado por: scheduler, api server, cluster store, controller manager, cloud controller.

COMMANDS:
Para arrancar minikube y poder usar kubectl:
minikube start

Para crear un POD (un pod es una collection de uno o mas containers)
kubectl run hello-world --image=nombreImage --port= 80 (es el port del container).

para ver los pods
kubectl get pods

...

- crear un pod con un .yml, creamos el yml
NOTA IMPORTANTE: ESTO ES UN EJEMPLO, EN LA VIDA REAL NUNCA CREAD PODS POR SI SOLOS OSEA CON EL KIND POD
YA QUE LOS PODS SON EPHIMERAL (con poca vida) Y APARTE SI MUEREN NO SE REVIVEN SOLOS.
lo que se hacen son DEPLOYMENTS

apiVersion: v1
kind: Pod
metadata:
  name: hello-world
  labels:
    name: hello-world
spec:
  containers:
  - name: hello-world
    image: amigoscode/kubernetes:hello-world
    resources:
      limits:
        memory: "128Mi"
        cpu: "500m"
    ports:
      - containerPort: 80

 -------------------

 DEPLOYMENT!

 apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: hello-world
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: hello-world
   template:
     metadata:
       labels:
         app: hello-world
     spec:
       containers:
       - name: hello-world
         image: amigoscode/kubernetes:hello-world
         resources:
           limits:
             memory: "128Mi"
             cpu: "500m"
         ports:
         - containerPort: 80


kubectl apply -f deployment.yml

NOTA: EL PORT ES DEL CONTAINER, SI QUEREMOS FIJAR DEL DEL HOST... para test podemos usar port fowarding.. pero no es receomendable.

- para ver todos los pods en todos los namespaces
kubectl get pods -A

kubectl get pod -n namespace

-para ver todo PODS, SERVICES ETC:
kubectl get all -A

-para describir un pod:
kubectl describe pod nombrepod

-DEBUGGING

- para ver los logs de un pod:
  kubectl logs nombrepod  -f
  si tiene mas de un container el pod:
  kubectl logs nombrepod -c nombreconteiner


- acceder dentro de un pod
kubectl exec -it nombrePod -- sh

- CHEATSHEET:
https://kubernetes.io/docs/reference/kubectl/cheatsheet/

- ver los deployments:
kubectl get deployments

- Replicaset: implement a backghround control loop that checks the desired number of pods are always present on the cluster.
kubectl get replicaset

- KUBERNETES SERVICES:
stable ip address, dns, port.
Lo que se hace es poner un service por delante de los pods y las replicas del deployment, ese service va a tener un selector
y en vez de usar el ip vamos a usar ese selector, y ese service va a conocer todos los endpoints de los pods que tambien tengan ese selector.

tipos:
ClusterIP(default): solo para comunicacion entre microservicios interna, no externa.
 NodePort,
 ExternalName,
 LoadBalancer.

 SERVICES Y DEPLOYMENTS VAN JUNTOS EN UN MISMO YML ej:
(AUTOCOMPLETION DE KUBERNETES PONER LA LETRA "k". ej: kser, kdep, kres, kcm, kpod)

apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: order
 spec:
 replicas: 2
   selector:
     matchLabels:
       app: order   // esto tiene que matchear con el name del service
   template:
     metadata:
       labels:
         app: order  // esto tiene que matchear con el name del service
     spec:
       containers:
       - name: order
         image: amigoscode/kubernetes:order-v1
         resources:
           limits:
             memory: "128Mi"
             cpu: "500m"
         ports:
         - containerPort: 8080  //mismo port que el service
---

apiVersion: v1
kind: Service
metadata:
  name: order
spec:
  selector:
    app: order  // esto tiene que matchear con el name del deployment
  ports:
    - port: 8080 //mismo port que el deployment
    targetPort: 8080 //mismo port que el deployment
  type: NodePort


luego para referimos al service, podemos referirnos por su IP que es fijo, pero lo mejor es hacerlo por su selector y puerto.
EJ: order:8080
y kubernetes hace su magia y lo encuentra.

loadBalancer. standars way of exposin applications to the internet
kubernetes creates a lb per service